<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
</head>

<body>
  <script>
    function genMatrix(cols, rows, n) {
      if (cols * rows % 2 !== 0) throw Error('cols*rows结果必须为偶数')
      const throttle = 0.6 // 有40%几率填充0
      let a = [...Array(cols * rows / 2)].map(() => Math.ceil(Math.random() > throttle ? 0 : Math.random() * n))
      a = [...a, ...a].sort(() => Math.random() - 0.5)
      return [...Array(rows)].map((value, y) => a.slice(y * cols, (y + 1) * cols))
    }

    function getMatrixValue(x, y, matrix) {
      return matrix[y][x]
    }

    function setMatrixValue(value, x, y, matrix) {
      matrix[y][x] = value
    }

    // exercise 2

    function getMatrixDimension(matrix) {
      return {
        rows: matrix.length,
        cols: matrix[0].length
      }
    }

    function findMatchByRule1(x, y, matrix) {
      const current = getMatrixValue(x, y, matrix)
      if (current === 0) return []

      const { cols, rows } = getMatrixDimension(matrix)

      const find = (vertical) => {
        const s = vertical ? y : x
        const b = vertical ? rows : cols

        for (let ss = s + 1; ss < b; ss++) {
          const a = getMatrixValue(...(vertical ? [x, ss, matrix] : [ss, y, matrix]))
          if (a === 0) continue
          if (a === current) return { value: current, points: [[x, y], vertical ? [x, ss] : [ss, y]] }
          break
        }
      }

      return [false, true].reduce((ret, vertical) => {
        const r = find(vertical)
        if (r) ret.push(r)
        return ret
      }, [])

      // const ret = []
      // for (let xx = x + 1; xx < cols; xx++) {
      //   const a = getMatrixValue(xx, y, matrix)
      //   if (a === 0) continue
      //   if (a === current) {
      //     ret.push({ value: a, points: [[x, y], [xx, y]] })
      //   }
      //   break
      // }

      // for (let yy = y + 1; yy < rows; yy++) {
      //   const a = getMatrixValue(x, yy, matrix)
      //   if (a === 0) continue
      //   if (a === current) {
      //     ret.push({ value: a, points: [[x, y], [x, yy]] })
      //   }
      //   break
      // }
      // return ret
    }

    function getAllLinks(matrix) {
      let ret = []
      const { cols, rows } = getMatrixDimension(matrix)
      for (let x = 0; x < cols; x++) {
        for (let y = 0; y < rows; y++) {
          const finding = findMatchByRule1(x, y, matrix)
          ret = [...ret, ...finding]
        }
      }
      return ret
    }

    function comparePoint(a, b) {
      const ydiff = a[1] - b[1]
      const xdiff = a[0] - b[0]
      if (ydiff !== 0) {
        return ydiff
      } else {
        return xdiff
      }

    }

    function isLinkable(a, b, matrix) {
      // a, b坐标完全一样
      if (a[0] === b[0] && a[1] === b[1]) return false
      // a, b坐标位置上的数字值不一样
      if (getMatrixValue(...a, matrix) !== getMatrixValue(...b, matrix)) return false

      if (comparePoint(a, b) > 0) { // a/b交换位置
        [a, b] = [b, a]
        // 传统写法
        // const temp = a
        // a = b
        // b = temp
      }
      const finding = findMatchByRule1(a[0], a[1], matrix)
      return finding.findIndex(f => f.points.findIndex(point => point[0] === b[0] && point[1] === b[1]) > -1) > -1
    }

    // 测试
    const matrix = [
      [4, 3, 2, 3],
      [0, 1, 0, 1],
      [2, 1, 0, 4],
      [1, 0, 2, 2]
    ]
    console.log(getAllLinks(matrix))
    console.log(isLinkable([0, 1], [0, 3], matrix)) // false
    console.log(isLinkable([1, 1], [1, 3], matrix)) // false
    console.log(isLinkable([1, 2], [1, 1], matrix)) // true
    console.log(isLinkable([3, 3], [2, 3], matrix)) // true
    console.log(isLinkable([3, 3], [2, 3], matrix)) // true

  </script>
</body>

</html>